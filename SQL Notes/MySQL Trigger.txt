MySQL Trigger
A trigger in MySQL is a set of SQL statements that reside in a system catalog. It is a special type of stored procedure that is invoked automatically in response to an event. Each trigger is associated with a table, which is activated on any DML statement such as INSERT, UPDATE, or DELETE.

A trigger is called a special procedure because it cannot be called directly like a stored procedure. The main difference between the trigger and procedure is that a trigger is called automatically when a data modification event is made against a table. In contrast, a stored procedure must be called explicitly.

Generally, triggers are of two types according to the SQL standard: row-level triggers and statement-level triggers.

Row-Level Trigger: It is a trigger, which is activated for each row by a triggering statement such as insert, update, or delete. For example, if a table has inserted, updated, or deleted multiple rows, the row trigger is fired automatically for each row affected by the insert, update, or delete statement.


Statement-Level Trigger: It is a trigger, which is fired once for each event that occurs on a table regardless of how many rows are inserted, updated, or deleted.

NOTE: We should know that MySQL doesn't support statement-level triggers. It provides supports for row-level triggers only.

Why we need/use triggers in MySQL?

We need/use triggers in MySQL due to the following features:

Triggers help us to enforce business rules.
Triggers help us to validate data even before they are inserted or updated.
Triggers help us to keep a log of records like maintaining audit trails in tables.
SQL triggers provide an alternative way to check the integrity of data.
Triggers provide an alternative way to run the scheduled task.
Triggers increases the performance of SQL queries because it does not need to compile each time the query is executed.
Triggers reduce the client-side code that saves time and effort.
Triggers help us to scale our application across different platforms.
Triggers are easy to maintain.

Limitations of Using Triggers in MySQL
MySQL triggers do not allow to use of all validations; they only provide extended validations. For example, we can use the NOT NULL, UNIQUE, CHECK and FOREIGN KEY constraints for simple validations.
Triggers are invoked and executed invisibly from the client application. Therefore, it isn't easy to troubleshoot what happens in the database layer.
Triggers may increase the overhead of the database server.
Types of Triggers in MySQL?
We can define the maximum six types of actions or events in the form of triggers:

Before Insert: It is activated before the insertion of data into the table.
After Insert: It is activated after the insertion of data into the table.
Before Update: It is activated before the update of data in the table.
After Update: It is activated after the update of the data in the table.
Before Delete: It is activated before the data is removed from the table.
After Delete: It is activated after the deletion of data from the table.
When we use a statement that does not use INSERT, UPDATE or DELETE query to change the data in a table, the triggers associated with the trigger will not be invoked.

Naming Conventions

Naming conventions are the set of rules that we follow to give appropriate unique names. It saves our time to keep the work organize and understandable. Therefore, we must use a unique name for each trigger associated with a table. However, it is a good practice to have the same trigger name defined for different tables.

The following naming convention should be used to name the trigger in MySQL:

(BEFOR | AFTER) table_name (INSERT | UPDATE | DELETE)  
Thus,

Trigger Activation Time: BEFORE | AFTER


Trigger Event: INSERT | UPDATE | DELETE

How to create triggers in MySQL?
We can use the CREATE TRIGGER statement for creating a new trigger in MySQL. Below is the syntax of creating a trigger in MySQL:

CREATE TRIGGER trigger_name    
    (AFTER | BEFORE) (INSERT | UPDATE | DELETE)  
         ON table_name FOR EACH ROW    
         BEGIN    
        --variable declarations    
        --trigger code    
        END;     


CREATE TABLE employee(  
    name varchar(45) NOT NULL,    
    occupation varchar(35) NOT NULL,    
    working_date date,  
    working_hours varchar(10)  
);


INSERT INTO employee VALUES    
('Robin', 'Scientist', '2020-10-04', 12),  
('Warner', 'Engineer', '2020-10-04', 10),  
('Peter', 'Actor', '2020-10-04', 13),  
('Marco', 'Doctor', '2020-10-04', 14),  
('Brayden', 'Teacher', '2020-10-04', 12),  
('Antonio', 'Business', '2020-10-04', 11);  


DELIMITER //  
  Create Trigger before_insert_empworkinghours   
BEFORE INSERT ON employee FOR EACH ROW  
BEGIN  
IF NEW.working_hours < 0 THEN SET NEW.working_hours = 0;  
END IF;  
END //  

..................................................................


MySQL BEFORE UPDATE Trigger
BEFORE UPDATE Trigger in MySQL is invoked automatically whenever an update operation is fired on the table associated with the trigger.

Syntax
The following is the syntax to create a BEFORE UPDATE trigger in MySQL:

DELIMITER $$   
CREATE TRIGGER trigger_name BEFORE UPDATE  
ON table_name FOR EACH ROW  
BEGIN  
   variable declarations  
   trigger code  
END$$  
DELIMITER ;  


Restrictions
We cannot update the OLD values in a BEFORE UPDATE trigger.
We can change the NEW values.
We cannot create a BEFORE UPDATE trigger on a VIEW.

BEFORE UPDATE Trigger Example
Let us understand how to create a BEFORE UPDATE trigger using the CREATE TRIGGER statement in MySQL with an example.

Suppose we have created a table named sales_info as follows:

CREATE TABLE sales_info (  
    id INT AUTO_INCREMENT,  
    product VARCHAR(100) NOT NULL,  
    quantity INT NOT NULL DEFAULT 0,  
    fiscalYear SMALLINT NOT NULL,  
    CHECK(fiscalYear BETWEEN 2000 and 2050),  
    CHECK (quantity >=0),  
    UNIQUE(product, fiscalYear),  
    PRIMARY KEY(id)  
);  

INSERT INTO sales_info(product, quantity, fiscalYear)  
VALUES  
    ('2003 Maruti Suzuki',110, 2020),  
    ('2015 Avenger', 120,2020),  
    ('2018 Honda Shine', 150,2020),  
    ('2014 Apache', 150,2020);  

DELIMITER $$  
CREATE TRIGGER before_update_salesInfo  
BEFORE UPDATE  
ON sales_info FOR EACH ROW  
BEGIN  
    DECLARE error_msg VARCHAR(255);  
    SET error_msg = ('The new quantity cannot be greater than 2 times the current quantity');  
    IF new.quantity > old.quantity * 2 THEN  
    SIGNAL SQLSTATE '45000'   
    SET MESSAGE_TEXT = error_msg;  
    END IF;  
END $$  
  
DELIMITER ; 


MySQL BEFORE DELETE Trigger

BEFORE DELETE Trigger in MySQL is invoked automatically whenever a delete operation is fired on the table. 

Syntax:

DELIMITER $$   
CREATE TRIGGER trigger_name BEFORE DELETE  
ON table_name FOR EACH ROW  
BEGIN  
   variable declarations  
   trigger code  
END$$  
DELIMITER ;  


CREATE TABLE salaries (  
    emp_num INT PRIMARY KEY,  
    valid_from DATE NOT NULL,  
    amount DEC(8 , 2 ) NOT NULL DEFAULT 0  
);  


INSERT INTO salaries (emp_num, valid_from, amount)  
VALUES  
    (102, '2020-01-10', 45000),  
    (103, '2020-01-10', 65000),  
    (105, '2020-01-10', 55000),  
    (107, '2020-01-10', 70000),  
    (109, '2020-01-10', 40000);  


CREATE TABLE salary_archives (  
    id INT PRIMARY KEY AUTO_INCREMENT,  
    emp_num INT,  
    valid_from DATE NOT NULL,  
    amount DEC(18 , 2 ) NOT NULL DEFAULT 0,  
    deleted_time TIMESTAMP DEFAULT NOW()  
);  


We will then create a BEFORE DELETE trigger that inserts a new record into the salary_archives table before a row is deleted from the salaries table.

DELIMITER $$  
  
CREATE TRIGGER before_delete_salaries  
BEFORE DELETE  
ON salaries FOR EACH ROW  
BEGIN  
    INSERT INTO salary_archives (emp_num, valid_from, amount)  
    VALUES(OLD. emp_num, OLD.valid_from, OLD.amount);  
END$$   
  
DELIMITER ;  


MySQL AFTER DELETE Trigger: The AFTER DELETE Trigger in MySQL is invoked automatically whenever a delete event is fired on the table. 

Syntax:

DELIMITER $$   
CREATE TRIGGER trigger_name AFTER DELETE  
ON table_name FOR EACH ROW  
BEGIN  
   variable declarations  
   trigger code  
END$$  
DELIMITER ;  


Restrictions
We can access the OLD rows but cannot update them in the AFTER DELETE trigger.
We cannot access the NEW rows. It is because there are no NEW row exists.
We cannot create an AFTER DELETE trigger on a VIEW.

Let's take an example:

CREATE TABLE salary (  
    emp_num INT PRIMARY KEY,  
    valid_from DATE NOT NULL,  
    amount DEC(8 , 2 ) NOT NULL DEFAULT 0  
);  


INSERT INTO salary (emp_num, valid_from, amount)  
VALUES  
    (102, '2020-01-10', 45000),  
    (103, '2020-01-10', 65000),  
    (105, '2020-01-10', 55000),  
    (107, '2020-01-10', 70000),  
    (109, '2020-01-10', 40000);  

CREATE TABLE total_salary_budget(  
    total_budget DECIMAL(10,2) NOT NULL  
);  


INSERT INTO total_salary_budget (total_budget)  
SELECT SUM(amount) FROM salary;  


DELIMITER $$  
  
CREATE TRIGGER after_delete_salaries  
AFTER DELETE  
ON salary FOR EACH ROW  
BEGIN  
   UPDATE total_salary_budget SET total_budget = total_budget - old.amount;  
END$$     
DELIMITER ;  


DELETE FROM salaries WHERE emp_num = 105;  

SELECT * FROM total_salary_budget;